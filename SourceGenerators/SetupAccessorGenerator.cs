using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace PCL.SourceGenerators
{
    [Generator]
    public class SetupAccessorGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 查找 SetupModel.json 文件
            var setupModelProvider = context.AdditionalTextsProvider
                .Where(static file => file.Path.EndsWith("SetupModel.json"))
                .Select(static (text, cancellationToken) => 
                {
                    var content = text.GetText(cancellationToken)?.ToString();
                    return content;
                })
                .Where(static content => !string.IsNullOrEmpty(content));

            context.RegisterSourceOutput(setupModelProvider, static (spc, content) => GenerateSetupCode(spc, content!));

            // 查找带有 ListenSetupChanged 特性的方法
            var setupListenerMethodsProvider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => s is MethodDeclarationSyntax method &&
                    method.AttributeLists.Count > 0,
                transform: static (ctx, _) => GetSetupListenerMethod(ctx))
                .Where(static x => x is not null);

            var allListenerMethodsProvider = setupListenerMethodsProvider.Collect();

            context.RegisterSourceOutput(allListenerMethodsProvider, 
                static (spc, methods) => GenerateSetupListenerRegisterer(spc, methods!));
        }

        private static void GenerateSetupCode(SourceProductionContext context, string jsonContent)
        {
            try
            {
                var setupModel = JsonSerializer.Deserialize<JsonElement>(jsonContent);
                
                // 生成 SetupEntries.g.cs
                GenerateSetupEntries(context, setupModel);
                
                // 生成 Setup.g.cs
                GenerateSetup(context, setupModel);
            }
            catch (System.Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "SG001",
                        "Failed to parse SetupModel.json",
                        "Error parsing SetupModel.json: {0}",
                        "SourceGenerator",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None,
                    ex.Message));
            }
        }

        private static void GenerateSetupEntries(SourceProductionContext context, JsonElement setupModel)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// ** 使用 IDE 删除该文件可能导致项目配置文件中的引用被删除，请谨慎操作 **");
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改，而是修改 SetupModel.json 文件");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace PCL.Core.ProgramSetup;");
            sb.AppendLine();
            sb.AppendLine("public static class SetupEntries");
            sb.AppendLine("{");

            var entryDictionary = new List<string>();
            
            ProcessNamespace(sb, setupModel, new List<string>(), "    ", entryDictionary);

            // 生成辅助方法
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// 根据 KeyName 获取一个 SetupEntry，如 VersionAdvanceJvm => SetupEntries.Instance.JvmArgs");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"keyName\">要获取的键名</param>");
            sb.AppendLine("    /// <returns>找到的 SetupEntry，如果未找到则返回 <see langword=\"null\"/></returns>");
            sb.AppendLine("    public static SetupEntry? ForKeyName(string keyName)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (keyName is null)");
            sb.AppendLine("            return null;");
            sb.AppendLine("        return EntryDictionary.TryGetValue(keyName, out var value) ? value : null;");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// 注册一个配置项，用于动态配置项的初始化");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"keyName\">键名</param>");
            sb.AppendLine("    /// <param name=\"source\">配置源</param>");
            sb.AppendLine("    /// <param name=\"defaultValue\">默认值</param>");
            sb.AppendLine("    /// <param name=\"isEntrypted\">是否加密</param>");
            sb.AppendLine("    /// <exception cref=\"global::System.ArgumentException\">已存在该键名</exception>");
            sb.AppendLine("    public static void RegisterEntry(string keyName, SetupEntrySource source, object defaultValue, bool isEntrypted = false)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (!EntryDictionary.TryAdd(keyName, new SetupEntry(source, keyName, defaultValue, isEntrypted)))");
            sb.AppendLine("            throw new global::System.ArgumentException($\"键名 {keyName} 已存在于配置项字典中\");");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// 存储了已记录的 SetupEntry，字典键为其 KeyName，用于 <see cref=\"ForKeyName\"/>");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static global::System.Collections.Concurrent.ConcurrentDictionary<string, SetupEntry> EntryDictionary = new()");
            sb.AppendLine("    {");
            
            foreach (var entry in entryDictionary)
            {
                sb.AppendLine(entry);
            }
            
            sb.AppendLine("    };");
            sb.AppendLine("}");

            context.AddSource("SetupEntries.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static void GenerateSetup(SourceProductionContext context, JsonElement setupModel)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// ** 使用 IDE 删除该文件可能导致项目配置文件中的引用被删除，请谨慎操作 **");
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改，而是修改 SetupModel.json 文件");
            sb.AppendLine();
            sb.AppendLine("namespace PCL.Core.ProgramSetup;");
            sb.AppendLine();
            sb.AppendLine("public static class Setup");
            sb.AppendLine("{");

            GenerateSetupProperties(sb, setupModel, new List<string>(), "    ");

            sb.AppendLine("}");

            context.AddSource("Setup.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static SetupListenerMethodInfo? GetSetupListenerMethod(GeneratorSyntaxContext context)
        {
            var methodDeclaration = (MethodDeclarationSyntax)context.Node;
            
            // 查找 ListenSetupChanged 特性
            var listenAttribute = methodDeclaration.AttributeLists
                .SelectMany(al => al.Attributes)
                .FirstOrDefault(a => a.Name.ToString().Contains("ListenSetupChanged"));
            
            if (listenAttribute == null)
                return null;
                
            // 确保方法是静态的
            if (!methodDeclaration.Modifiers.Any(SyntaxKind.StaticKeyword))
                return null;
            
            // 获取特性参数（setup key）
            string? setupKey = null;
            if (listenAttribute.ArgumentList?.Arguments.Count > 0)
            {
                var firstArg = listenAttribute.ArgumentList.Arguments[0];
                if (firstArg.Expression is LiteralExpressionSyntax literal && 
                    literal.Token.IsKind(SyntaxKind.StringLiteralToken))
                {
                    setupKey = literal.Token.ValueText;
                }
            }
            
            if (string.IsNullOrEmpty(setupKey))
                return null;
            
            // 获取方法名
            var methodName = methodDeclaration.Identifier.ValueText;
            
            // 获取第一个参数的类型
            string parameterType = "object";  // 默认类型
            if (methodDeclaration.ParameterList.Parameters.Count > 0)
            {
                var firstParam = methodDeclaration.ParameterList.Parameters[0];
                if (firstParam.Type != null)
                {
                    parameterType = firstParam.Type.ToString();
                }
            }
            
            return new SetupListenerMethodInfo(setupKey!, methodName, parameterType);
        }
        
        private static void GenerateSetupListenerRegisterer(SourceProductionContext context, ImmutableArray<SetupListenerMethodInfo> methods)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// ** 使用 IDE 删除该文件可能导致项目配置文件中的引用被删除，请谨慎操作 **");
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改，而是修改 SetupListener.cs 文件");
            sb.AppendLine();
            sb.AppendLine("namespace PCL.Core.ProgramSetup;");
            sb.AppendLine();
            sb.AppendLine("public static class SetupListenerRegisterer");
            sb.AppendLine("{");
            sb.AppendLine("    public static void RegisterClassListeners(System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<SetupListener.ValueChangedHandler>> dict)");
            sb.AppendLine("    {");
            
            // 按 setupKey 分组方法
            var methodsByKey = methods.GroupBy(m => m.SetupKey).ToDictionary(g => g.Key, g => g.ToList());
            
            foreach (var kvp in methodsByKey)
            {
                var setupKey = kvp.Key;
                var keyMethods = kvp.Value;
                
                sb.Append("        dict[\"").Append(setupKey).Append("\"] = [");
                
                for (int i = 0; i < keyMethods.Count; i++)
                {
                    var method = keyMethods[i];
                    
                    if (method.ParameterType == "object")
                    {
                        sb.Append("SetupListener.").Append(method.MethodName);
                    }
                    else
                    {
                        sb.Append("(o, n, p) => SetupListener.").Append(method.MethodName)
                          .Append("((").Append(method.ParameterType).Append(")o, (")
                          .Append(method.ParameterType).Append(")n, p)");
                    }
                    
                    if (i < keyMethods.Count - 1)
                    {
                        sb.Append(", ");
                    }
                }
                
                sb.AppendLine("];");
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            context.AddSource("SetupListenerRegisterer.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static void ProcessNamespace(StringBuilder sb, JsonElement element, List<string> namespacePath, string indent, List<string> entryDictionary)
        {
            foreach (var property in element.EnumerateObject())
            {
                if (property.Name.StartsWith("ns:"))
                {
                    var namespaceName = property.Name.Substring(3);
                    sb.AppendLine($"{indent}public static class {namespaceName}");
                    sb.AppendLine($"{indent}{{");
                    
                    var newPath = new List<string>(namespacePath) { namespaceName };
                    ProcessNamespace(sb, property.Value, newPath, indent + "    ", entryDictionary);
                    
                    sb.AppendLine($"{indent}}}");
                }
                else 
                {
                    var isDynamic = property.Name.StartsWith("dyn:");
                    var entryName = isDynamic ? property.Name.Substring(4) : property.Name;
                    var entryData = property.Value;
                    
                    if (entryData.TryGetProperty("key", out var keyProp) &&
                        entryData.TryGetProperty("source", out var sourceProp) &&
                        entryData.TryGetProperty("value", out var valueProp) &&
                        entryData.TryGetProperty("encrypted", out var encryptedProp))
                    {
                        var key = keyProp.GetString()!;
                        var source = FormatEntrySource(sourceProp.GetString()!);
                        var valueInfo = FormatValue(valueProp);
                        var encrypted = encryptedProp.GetBoolean().ToString().ToLowerInvariant();
                        var fullEntryPath = string.Join(".", namespacePath.Concat(new[] { entryName }));
                        
                        if (isDynamic)
                        {
                            // 动态配置项生成属性，通过ForKeyName获取
                            sb.AppendLine($"{indent}public static SetupEntry {entryName} => global::PCL.Core.ProgramSetup.SetupEntries.ForKeyName(\"{key}\")!;");
                        }
                        else
                        {
                            // 静态配置项生成字段
                            sb.AppendLine($"{indent}public static readonly SetupEntry {entryName} = new SetupEntry({source}, \"{key}\", {valueInfo.formattedValue}, {encrypted});");
                            // 只有静态配置项才加入EntryDictionary
                            entryDictionary.Add($"        [\"{key}\"] = {fullEntryPath},");
                        }
                    }
                }
            }
        }

        private static void GenerateSetupProperties(StringBuilder sb, JsonElement element, List<string> namespacePath, string indent)
        {
            foreach (var property in element.EnumerateObject())
            {
                if (property.Name.StartsWith("ns:"))
                {
                    var namespaceName = property.Name.Substring(3);
                    sb.AppendLine($"{indent}public static class {namespaceName}");
                    sb.AppendLine($"{indent}{{");
                    
                    var newPath = new List<string>(namespacePath) { namespaceName };
                    GenerateSetupProperties(sb, property.Value, newPath, indent + "    ");
                    
                    sb.AppendLine($"{indent}}}");
                }
                else
                {
                    var isDynamic = property.Name.StartsWith("dyn:");
                    var entryName = isDynamic ? property.Name.Substring(4) : property.Name;
                    var entryData = property.Value;
                    
                    if (entryData.TryGetProperty("source", out var sourceProp) &&
                        entryData.TryGetProperty("value", out var valueProp))
                    {
                        var source = sourceProp.GetString()!;
                        var valueInfo = FormatValue(valueProp);
                        var fullNamespacePath = string.Join(".", namespacePath.Concat(new[] { entryName }));
                        
                        if (source != "instance")
                        {
                            sb.AppendLine($"{indent}public static {valueInfo.type} {entryName}");
                            sb.AppendLine($"{indent}{{");
                            sb.AppendLine($"{indent}    get => SetupService.{valueInfo.getMethod}(SetupEntries.{fullNamespacePath});");
                            sb.AppendLine($"{indent}    set => SetupService.{valueInfo.setMethod}(SetupEntries.{fullNamespacePath}, value);");
                            sb.AppendLine($"{indent}}}");
                        }
                        else
                        {
                            sb.AppendLine($"{indent}public static PCL.Core.Utils.ParameterizedProperty<string, {valueInfo.type}> {entryName} = new()");
                            sb.AppendLine($"{indent}{{");
                            sb.AppendLine($"{indent}    GetValue = gamePath => SetupService.{valueInfo.getMethod}(SetupEntries.{fullNamespacePath}, gamePath),");
                            sb.AppendLine($"{indent}    SetValue = (gamePath, value) => SetupService.{valueInfo.setMethod}(SetupEntries.{fullNamespacePath}, value, gamePath)");
                            sb.AppendLine($"{indent}}};");
                        }
                    }
                }
            }
        }

        private static (string formattedValue, string type, string getMethod, string setMethod) FormatValue(JsonElement value)
        {
            if (value.ValueKind == JsonValueKind.Null)
            {
                throw new System.NotSupportedException("SetupModel.json 中某个默认值为 null，不受支持。");
            }

            switch (value.ValueKind)
            {
                case JsonValueKind.String:
                    var strVal = value.GetString()!;
                    return ($"\"{strVal}\"", "string", "GetString", "SetString");
                    
                case JsonValueKind.True:
                case JsonValueKind.False:
                    var boolVal = value.GetBoolean().ToString().ToLowerInvariant();
                    return (boolVal, "bool", "GetBool", "SetBool");
                    
                case JsonValueKind.Number:
                    // 支持 C# 侧的 Int32：处理 JSON 中可能的 long/double/decimal 类型
                    try
                    {
                        // 尝试直接获取 Int32
                        var intVal = value.GetInt32();
                        return (intVal.ToString(), "int", "GetInt32", "SetInt32");
                    }
                    catch (System.FormatException)
                    {
                        // 如果直接获取失败，尝试其他数字类型
                        if (value.TryGetInt64(out var longVal))
                        {
                            if (longVal < int.MinValue || longVal > int.MaxValue)
                            {
                                throw new System.ArgumentOutOfRangeException($"SetupModel.json 中存在超出 Int32 范围的整数值：{longVal}");
                            }
                            return (((int)longVal).ToString(), "int", "GetInt32", "SetInt32");
                        }
                        
                        if (value.TryGetDouble(out var doubleVal))
                        {
                            // 检查是否为整数
                            if (doubleVal != System.Math.Truncate(doubleVal))
                            {
                                throw new System.ArgumentException($"SetupModel.json 中存在非整数数值：{doubleVal}");
                            }
                            
                            // 检查范围
                            if (doubleVal < int.MinValue || doubleVal > int.MaxValue)
                            {
                                throw new System.ArgumentOutOfRangeException($"SetupModel.json 中存在超出 Int32 范围的整数值：{doubleVal}");
                            }
                            
                            return (((int)System.Math.Truncate(doubleVal)).ToString(), "int", "GetInt32", "SetInt32");
                        }
                        
                        if (value.TryGetDecimal(out var decimalVal))
                        {
                            // 检查是否为整数
                            if (decimalVal != System.Math.Truncate(decimalVal))
                            {
                                throw new System.ArgumentException($"SetupModel.json 中存在非整数数值：{decimalVal}");
                            }
                            
                            // 检查范围
                            if (decimalVal < int.MinValue || decimalVal > int.MaxValue)
                            {
                                throw new System.ArgumentOutOfRangeException($"SetupModel.json 中存在超出 Int32 范围的整数值：{decimalVal}");
                            }
                            
                            return (((int)System.Math.Truncate(decimalVal)).ToString(), "int", "GetInt32", "SetInt32");
                        }
                        
                        throw new System.NotSupportedException($"无法解析的数字值: {value}");
                    }
                    
                default:
                    throw new System.NotSupportedException($"不支持的值类型: {value.ValueKind}");
            }
        }

        private static string FormatEntrySource(string source)
        {
            return source switch
            {
                "local" => "SetupEntrySource.PathLocal",
                "global" => "SetupEntrySource.SystemGlobal",
                "instance" => "SetupEntrySource.GameInstance",
                _ => throw new System.ArgumentException($"未知的配置源: {source}")
            };
        }
    }

    public class SetupListenerMethodInfo
    {
        public SetupListenerMethodInfo(string setupKey, string methodName, string parameterType)
        {
            SetupKey = setupKey;
            MethodName = methodName;
            ParameterType = parameterType;
        }

        public string SetupKey { get; }
        public string MethodName { get; }
        public string ParameterType { get; }
    }
}